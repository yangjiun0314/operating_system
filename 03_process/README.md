# OS Week 03 — Processes + Threads (up to Amdahl)
3주차에 다룬 **Ch.3 Processes 전범위**와 **Ch.4 Threads & Concurrency 중 아믈달(암달)의 법칙까지**를 통합 정리한다.  

---

## 0) 이번 주 범위(스코프)
- Processes: 개념·구성, PCB, 상태/스케줄링, 컨텍스트 스위치, 생성/종료, IPC(공유 메모리 vs 메시지 패싱, 버퍼링/동기화 기초)
- Threads: 스레드의 동기(응답성/공유/경제성/확장성), 동시성 vs 병렬성, **아믈달(암달)의 법칙**(여기까지)

---

## 1) Processes — 핵심 정의와 구성
### 1.1 프로세스란?
- **프로그램(수동적, 디스크)** ≠ **프로세스(능동적, 메모리에서 실행 중)**  
- 하나의 프로그램으로도 여러 프로세스가 동시에 존재 가능(예: 편집기 여러 창)

### 1.2 프로세스 메모리 구성(전형)
- **텍스트(코드)**, **데이터(전역/정적)**, **BSS(초기화X 전역)**, **힙(동적 할당, 위로 성장)**, **스택(호출/지역, 아래로 성장)**, **공유 라이브러리(PLT/GOT)**  
- 현재 실행 맥락: **PC(Program Counter)**, **레지스터 집합**, **스택 포인터** 등

### 1.3 PCB(Process Control Block)
- **상태(state)**, **PC/레지스터**, **스케줄링 정보**(우선순위, 큐 링크), **메모리 관리 정보**(페이지 테이블/세그먼트), **회계 정보**(CPU 시간 등), **I/O 상태**(열린 파일/디바이스)  
- 커널 내부에서는 구조체(예: Linux `task_struct`)로 관리하며, 부모/자식/주소공간/파일 테이블 포인터를 유지

---

## 2) 상태·스케줄링·컨텍스트 스위치
### 2.1 상태(State)와 큐
- **New → Ready → Running → Waiting → Terminated**  
- **Ready 큐**: CPU를 기다리는 프로세스, **Wait/Block 큐**: I/O/이벤트 대기  
- 스케줄러는 준비 큐에서 다음 실행 대상을 선택

### 2.2 컨텍스트 스위치(Context Switch)
- 이전 프로세스의 문맥(레지스터/PC 등)을 PCB에 저장하고, 새 프로세스 문맥을 로드  
- **순수 오버헤드**(유용한 작업을 하지 않음). HW 지원(레지스터 수, TLB 컨텍스트 태깅 등)과 OS 구현 복잡도에 따라 비용이 달라짐

---

## 3) 생성·종료(UNIX 관례 포함)
- **생성**: 부모→자식 트리. 자원 공유는 정책적으로 (전부/부분/없음) 선택 가능  
- UNIX: `fork()`(부모 복제) → **자식이** `exec()`(주소공간을 새 실행파일로 교체) → 부모는 `wait()`로 자식 종료 수거  
- **종료**: `exit(status)`로 종료 코드 반환. 부모가 수거하지 않으면 **좀비**(PCB 잔류), 부모가 먼저 죽으면 **고아**(init/시스템이 위탁 수거)

---

## 4) IPC — Interprocess Communication
### 4.1 모델
- **공유 메모리(Shared Memory)**: 주소공간 일부를 매핑해 **사용자 레벨에서** 읽고 쓰기. 빠르지만 **동기화**(상호배제/조건동기)가 핵심 과제  
- **메시지 패싱(Message Passing)**: **커널이 중개**하는 `send/receive`. 주소공간을 공유하지 않아 격리/보안에 유리

### 4.2 버퍼링과 동기/비동기
- **버퍼 용량**: 0(랜데부, 동기식) / 유한 / 무한  
- **통신 방식**: 동기(블로킹) vs 비동기(논블로킹) — 설계 목표(지연/처리량/격리)에 맞춰 결정

### 4.3 생산자–소비자(개념 골자)
- **경계 버퍼**(ring buffer)에서 `in/out` 포인터를 사용  
- 단순 카운터 증감도 **원자성** 없으면 경쟁 상태 발생 → 6·7장에서 다룰 동기화 원리로 해결

---

## 5) Threads — 동기/개념·동시성·아믈달(암달)
### 5.1 왜 스레드인가(동기)
- **응답성**(한 작업이 I/O로 블로킹돼도 다른 스레드가 계속 응답)  
- **자원 공유 용이**(프로세스 자원을 스레드가 공유)  
- **경제성**(생성/전환 오버헤드가 프로세스보다 작음)  
- **확장성**(코어 수 증가에 성능 확장)

### 5.2 동시성 vs 병렬성
- **동시성**: 단일 코어에서 **스케줄링**으로 교대로 실행되어 “동시에 보이는” 상태  
- **병렬성**: 다중 코어에서 실제 동시에 실행  
- **데이터 병렬성** vs **태스크 병렬성** 구분(데이터를 나눠 같은 연산/서로 다른 일을 병렬로)

### 5.3 아믈달(암달)의 법칙(시험 핵심)
- 전체 작업 중 병렬화 불가능한 **직렬 비율 S**가 있으면, 코어 수 \(N\)을 무한대로 키워도 최대 가속비는 **\(1 / S\)** 를 넘지 못함  
- 예: S=0.1(10% 직렬)인 작업은 이론상 최대 **10배** 가속에 수렴  
- 결론: 병렬화를 늘릴 땐 **직렬 구간을 먼저 줄이는 설계**가 중요

> 주의: 이번 주는 **스레드 매핑 모델(1:1/M:1/M:M 등), 신호/취소/TLS, 스케줄러 액티베이션**은 다루지 않음(다음 주 예정)

---

## 6) 한 페이지 요약(암기용)
- **프로세스**: 실행 중인 프로그램(텍스트/데이터/BSS/힙/스택 + PC/레지스터). **PCB**가 상태/자원/열린 파일을 보유  
- **상태/스케줄링**: Ready/Wait 큐, **컨텍스트 스위치=오버헤드**  
- **IPC**: 공유 메모리(빠름/동기화 과제) vs 메시지 패싱(격리/간편) + 버퍼링(0/유한/무한)  
- **스레드**: 응답성/공유/경제성/확장성. **동시성**(보이는 동시에) vs **병렬성**(실제 동시에). **암달**: 최대 가속비 \(≤ 1/S\)
