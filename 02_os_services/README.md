# OS02 — Operating-System Services
운영체제가 **사용자·프로그램에 제공하는 서비스**와 **API→System Call Interface(SCI)→Kernel** 흐름, **프로그램 실행 파이프라인**(컴파일→링크→적재/재배치→엔트리), **시스템 콜 분류/전달**, **OS 구조(모놀리식/마이크로커널/모듈/하이브리드)** 를 실전 감각으로 정리한다.

---

## 0) 학습 목표 (Checklist)
- [ ] 사용자 서비스 vs 시스템 효율/안정 서비스의 차이와 예시를 설명한다.  
- [ ] **API 호출**이 **SCI(번호 테이블)** 를 통해 **커널 루틴**으로 이어지고 **상태/리턴값**이 돌아오는 흐름을 말로 그린다.  
- [ ] **시스템 콜 파라미터 전달 3법**(레지스터/메모리 블록/스택)을 비교한다.  
- [ ] **시스템 콜 6분류**(프로세스/파일/장치/정보/통신/보호)와 대표 콜을 외운다.  
- [ ] **프로그램 실행**을 “무엇·어디서·누가·어떻게” 관점으로 설명한다.  
- [ ] **모놀리식/마이크로커널/모듈/하이브리드**의 트레이드오프를 비교한다.

---

## 1) 서비스 맵: 사용자 vs 시스템
### A. 사용자에게 직접 유용한 서비스
- **UI**: CLI/GUI/터치(모바일 제스처·IME 포함)  
- **프로그램 실행/종료**: 적재(load)·시작(start)·종료(exit/abort)·상태 코드  
- **I/O**: 장치 차이를 숨기고 일관 인터페이스(버퍼링/캐싱/스풀링)  
- **파일 시스템**: 파일·디렉터리 조작, 메타데이터(권한/타임스탬프)  
- **통신(IPC/네트워크)**: 공유메모리, 파이프/소켓, 메시지큐  
- **오류 검출**: 하드웨어/소프트웨어 오류 감지, 예외/시그널, 로깅

### B. 시스템 효율·안정 서비스
- **자원 할당**: CPU(스케줄러), 메모리(가상메모리/할당), 저장장치(블록/저널링/스케줄링), I/O(드라이버/큐)  
- **회계/로깅**: 사용량 측정, 감사(audit)  
- **보호·보안**: 모드 분리(User/Kernel), 접근 제어, 주소공간 격리, 인증

---

## 2) 프로그램 실행: 무엇을·어디서·누가·어떻게
### (0) 준비 — 컴파일·링크
- **컴파일러**: 소스 → **재배치 가능 오브젝트(.o)**  
- **링커**: 여러 .o + 라이브러리 → **실행파일(ELF/PE 등 표준 포맷)**

### (1) 실행 트리거 — “누가 시작?”
- **셸/런처(부모 프로세스)** 가 새 **프로세스 컨테이너(PID, 주소공간)** 생성  
- **로더**에게 “이 실행파일을 저 주소공간에 올려라” 지시 (UNIX: `fork` → `execve`)

### (2) 로더가 하는 일 — “무엇/어디서→어디로/어떻게”
- **무엇**: 코드/데이터/메타데이터(+ 필요 시 **동적 라이브러리** DLL/so)  
- **어디서→어디로**: **디스크** → 새 프로세스의 **가상 주소공간**  
- **어떻게**: **재배치(relocation)**, 페이지 매핑, 초기 **스택/레지스터** 설정, **엔트리 포인트** 점프  
- **동적 링크/로딩**: 호출 시점에 필요한 루틴만 로딩(메모리 절약, **사본 공유**)

### (3) 전형적 메모리 레이아웃(개념)
`텍스트(코드) / 데이터 / BSS / 힙(위로 확장) / 스택(아래로 확장) / 공유 라이브러리(PLT/GOT)`

---

## 3) 사용자 ↔ OS 인터페이스 (API → SCI → Kernel)
- 앱은 **API(POSIX/Win32/Java)** 를 호출한다.  
- **런타임 라이브러리(RTE)** 가 **System Call Interface(SCI)** 로 인자와 **시스템 콜 번호**를 전달한다.  
- **SCI**는 **번호 테이블**로 해당 **커널 루틴**을 호출하고 **상태/리턴값**을 앱에 되돌린다.  
- (참고) 리눅스 x86-64 호출 규약: 번호=RAX, 인자=RDI/RSI/RDX/R10/R8/R9, 리턴=RAX(음수→`errno`)

---

## 4) 시스템 콜 파라미터 전달 3법
- **레지스터**: 빠르고 단순(인자 수 제한)  
- **메모리 블록 주소 전달**: 큰/가변 인자 구조체를 포인터 1개로 전달  
- **스택**: ABI/호출 규약에 따라 스택으로 전달(아키텍처 의존)

---

## 5) 시스템 콜 6분류(대표 콜 예시)
- **프로세스**: `fork`, `execve`, `exit`, `wait`, `kill`, `getpid`  
- **파일**: `open`, `read`, `write`, `lseek`, `stat`, `close`  
- **장치**: `ioctl`, `mmap`, `fsync`  
- **정보**: `gettimeofday`, `uname`, `getrusage`  
- **통신**: `pipe`, `socket`, `bind`, `connect`, `send/recv`, `shmget/shmat`  
- **보호**: `chmod`, `chown`, `umask`, `setuid`/`setgid`  

암기 구호: **프로·파·장·정·통·보**

---

## 6) OS 구조 — 장단 요약
- **모놀리식**: 한 주소공간, 내부 호출 빠름(성능↑) / 커널 거대·복잡, 오류 영향 범위 큼  
- **마이크로커널**: 핵심(스케줄링·메모리·IPC)만 커널, 나머지 **유저 공간** / 격리·이식성·신뢰성↑, **IPC 오버헤드**  
- **모듈식(LKM)**: 코어 + 로드 가능한 모듈(드라이버/파일시스템) / 성능·유연성 절충  
- **하이브리드**: 실무 OS는 혼합(Linux=모놀리식+모듈, macOS/iOS=Mach+BSD)